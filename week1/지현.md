## ep4. 변수 

#### 목차
[1. 변수란 무엇인가](#변수)

#### 1. 변수란 무엇인가
프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념 

메모리 = 데이터를 저장할 수 있는 메모리 셀의 집합체 
각 셀은 메모리 주소를 가지고 이는 주소가 어디에 있는지 나타냄 , 직접 접근하는 것은 오류발생가능성 높음 (코드실행시 변경되기 때문)

변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 or 메모리 공간을 식별하기 위해 붙인 이름 (재사용 가능)

변수명(참조) => 변수 값(할당)

변수명 = 식별자
식별자는 메모리 주소와 매핑 관계를 맺어서 참조(메모리 주소를 통해 값을 기억)

#### 2. 변수 선언
메모리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장하도록 준비
* var, let, const
변수 선언문 = 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보함 
```js
 console.log(score); // undefined (변수 호이스팅)
 var score; // 변수 선언 및 초기화 (런타임 이전 단계에서 실행)
 score = 80; // 값 할당
 console.log(score); // 80
```
변수 선언은 아래 두 단계를 통해 이루어진다. 
1) 선언 단계(이름 등록) 
2) 초기화 단계(메모리 공간 확보, undefined 할당ㅇ) 
값은 할당하지 않았으나 메모리 공간이 확보 = undefined 

* 실행 컨텍스트 : js 엔진이 소스코드를 평가하고 실행하기위해 필요한 환경을 제공하고 실행 결과를 관리하는 영역 
* 변수 재할당 : 현 변수에 저장된 값을 버리고 새로운 값을 저장(var은 가능, const는 불가)

#### 3. 식별자 이름 규칙 
값을 구별해낼 수 있는 고유한 이름 
- 특수문자를 제외한 문자/숫자/_/$로 시작한 식별자 사용 (예약어 x)
- 변수 존재 목적을 쉽게 이해할 수 있도록 설정해야 한다 
- 네이밍 컨벤션(camelCase, PascalCase 주로사용)

## ep5. 표현식과 문 

#### 1. 값
표현식이 평가(식을 해석해 참조)되어서 생성된 결과
변수는 하나의 값을 저장하기 위해서 확보한 메모리 공간 or 메모리 공간을 식벼하기 위해 붙인 이름 

#### 2. 리터럴 
사람이 이해할 수 있는 문자, 약속된 기호를 사용해 값을 생성하는 표기법을 말한다. 
런타임 시, 리터럴의 값을 평가해 생성한다. 

#### 3. 표현식(expression)
값으로 평가될 수 있는 문, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조함 
문법적으로 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다는 것을 의미함 
표현식이 아닌 문은 값으로 평가될 수 없음(변수 선언문은 표현식으로 사용할 수 없음)
```js
    var foo = var x;  // syntaxError : Unexpected token var
    x = 100; // 할당문 = 표현식
```

#### 4. 문(statement)
```js
var sum = 1+2; 
```
프로그램을 구성하는 기본단위, 최소 실행 단위(명령문)
토큰 : 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소

#### 5. 세미콜론
문의 종료, 생략 가능한 옵션
코드 블록은 자체 종결성의 의미

## ep6. 데이터 타입

#### 1) 데이터 타입 
원시 타입 : number, string, boolean, undefined, null, symbol 
객체 타입 : 객체, 함수, 배열

* 숫자 1 vs 문자 "1"
사용용도와 목적이 다르며, 확보해야 할 메모리 공간 및 메모리에 저장되는 2진수도 다름

#### 2) 숫자 타입 
JS는 하나의 숫자 타입만 존재함(실수)
리터럴은 모두 2진수로 저장되기에, 정수만을 위한 타입이 없고, 모든 수를 실수로 처리함 
Infinity, -Infinity, not-a-number로 표현함 
```js
console.log(10/0); // Infinity
console.log(10/-0); // -Infinity
console.log(1*'String'); // NaN
```

#### 3) 문자열 타입
`""`, `''` 으로 문자열 표시 
JS의 문자열은 원시 타입이며, 변경 불가능한 값임

#### 4) 템플릿 리터럴 ``
멀티라인 문자열, 태그트 템플릿, 표현식 삽입 등 편리한 문자열 처리 기능 제공 
* 멀티라인 문자열 
이스케이프 시퀀스를 사용하지 않아도 줄바꿈 가능, 공백 적용 
* 표현식 삽입 : 간단한 문자열 삽입
`${}`로 표현식을 감싸서 사용, 문자열로 타입의 강제 변환이 일어남 

#### 5) 불리언 타입

#### 6) undefined & null
개발자가 의도적으로 할당하기 위한 값이 아닌, 변수를 초기화할 때, garbage value를 업애기 위해 사용 
값이 없다는 것을 명시할 때는 null을 할당

변수에 값을 명시하고자 할 때는 null 을 사용
변수에 값이 없음을 명시함(더 이상 값을 참조하지 않음을 표시)
함수가 유혀한 값을 반환할 수 없는 경우에는 명시적으로 null을 반환함 

#### 6) symbol 타입 
다른 값과 중복되지 않는 값, 객체의 유일한 프로퍼티 키를 만들기 위해 사용 

#### 7) 데이터 타입의 필요성
* 데이터 타입에 대한 메모리 공간의 확보와 참조(메모리 크기 결정)
* symbol table이라는 자료 구조를 통해 식별자를 키로 바인딩된 값의 메모리 주소/데이터 타입/스코프를 관리 
* 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위함 
* 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해 

#### 8) 동적 타이핑
재할당에 의해서 변수의 타입은 언제든지 동적으로 변화 가능하다. (JS, Python, php, ruby)
사전에 변수의 타입, 값 종류를 선언하는 정적 타입은 컴파일을 통해 타입 체크를 통해서 안정적인 코드를 구현(C, C++, JAVA)
var, const, let 키워드를 사용해 선언하고, 데이터 타입의 제약 없이 자유롭게 할당 가능 (타입 추론)
```js
// typeof를 통해 변수에 할당된 값의 데이터 타입을 반환
var foo;
console.log(typeof foo); // undefined
foo = 3;
console.log(foo); // number 
foo = {}; 
console.log(typeof foo); // object
```

* 동적 타입 언어의 단점 및 주의사항
변수가 변경가능하기에 복잡한 프로그램에서는 타입 확인이 어려움(높은 유연성, 낮은 신뢰성)
1) 변수는 꼭 필요한 경우에 한해 제한적으로 사용함(재할당에 의한 변경가능성 최소화)
2) 변수의 유효 범위는 최대한 좁게 만들어 부작용을 억제
3) 전역 변수는 어디서든 참조/변경가능하기에 최대한 사용하지 않도록 함
4) 변수보다는 상수를 사용해 값의 변경을 억제함
5) 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 짓기(협업과 생산성 향상)

## ep7. 연산자
** 피연산자 : 연산의 대상 (값을 명시)
** 연산자 : 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산을 수행 

#### 1) 산술 연산자 
피연산자를 대상으로 계산을 수행해 새로운 숫자 값을 듦

* 이항 산술 연산자 : 2개의 피연산자를 산술 연산해 숫자 값을 만듦
`+`,`-`,`%` 산술 연산을 해도 피연산자의 값을 변경하는 부수 효과는 없음, 새로운 값을 만들어냄 
* 단항 산술 연산자 : 1개의 피연산자를 산술 연산해 숫자 값을 만듦
`++`,`--` 로 부수 효과가 일어나 피연산자의 값을 변경함(암묵적 할당)

전위증가감소연산자는 피연산자의 값을 증가하고 타 연산을 수행 
후위증가감소연산자는 다른연산을 수행하고, 피연산자의 값을 수행 
```js 
// 선 할당 후 감소
result = x--;
console.log(result, x); // 7 6
// 선 감소 후 할당 
result = --x;
console.log(result, x); // 5 5
```

#### 단항 산술 연산자 
* + 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작함
* 숫자 타입이 아닌 피연산자에 + 단항 연산자를 사용하면 피연산자를 숫자 타입으로 변환해 반환 
* 단항 연산자를 피연산자의 부호를 반전한 값을 반환 

#### 문자열 연결 연산자 
+ 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작 , 그 외에는 산술연산자 
```js
'1'+2; // '12'
1+true; // 1+1 = 2 (암묵적 타입 변환)
1+false; // 1+0 = 0
1+ undefined; //NaN, 숫자 타입 변환 불가 
```

#### 할당 연산자
우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당함 
좌항의 변수에 값을 할당하므로 변수 값이 변화는 부수 효과 존재 
```js
var x;
x = 10;
console.log(x); // 10
console.log(x=10); // 할당문은 표현식
```

#### 비교 연산자 
좌항과 우항의 피연산자르 비교하고 결과를 불리언 값으로 반환한다.
* 동등/일치 비교 연산
- 동등비교 : 좌항 및 우항의 피연산자를 비교할 때 암묵적 타입 변화을 통해 타입을 일치시킨 후 같은 값인지 비교함 
- 일치비교 : 좌항 우항 피연산자 타입이 같고, 값도 같은 경우에 한해 true 반환 (예측이 쉬움)

- NaN : 자신과 일치하지 않는 유일한 값
```js
// isNaN함수는 지정한 값이 NaN인지 비교하고 결과를 boolean으로 반환 
Number.isNaN(NaN); // true
Number.isNaN(1 + undefined) // true
```
* 부동등비교 / 불일치 비교 연산 

#### 대소관계비교

#### 삼항조건연산자
조건시그이 평가 결과에 따라서 반환 값을 지정 
```js
조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값
```
조건문과의 차이점은 삼항연산자의 표현식은 값처럼 사용할 수 있지만 if~else문은 값처럼 사용 불가능함 
```js
var result = if(x%2) {result = '홀수'} else {result = '짝수'} // syntaxError : Unexpected token if
```
#### 쉼표 연산자
왼쪽 연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자 평가 결과를 반환 

#### 그룹 연산자 
()소괄호로 감싸인 그룹 연ㅅ나자를 자신의 피연산자인 표현식을 가장 먼저 평가함

#### typeof 연산자
```js
typeof `` // "string"
typeof null // "object" => 버그 null의 타입을 확인하고자 할때는 === 사용
typeof undeclared; // 선언하지 않은 식별자를 사용할 경우, undefined  ? 선언하지 않는데 undefined? typeof가되는 순간 할당이 아닌 선언이 되서 그런건가?
```

#### 지수 연산자 
좌항의 피연산자를 밑으로 우항 피연산자를 지수로 거듭제곱해 반환 
```js
2 ** 2; // 4 > Math.pow보다 가독성이 좋음
2 ** 2.5; // 5.65685424
Math.pow(2,2)
```
